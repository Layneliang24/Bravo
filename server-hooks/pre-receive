#!/bin/bash
# 🛡️ Server-Side Pre-Receive Hook - Ultimate Protection Layer
# 用途：在服务器端运行所有本地检查，防止绕过本地钩子
# 原则：快速失败，一旦检查失败立即终止
# 部署：适用于自建Git服务器（Gitea/GitLab/GitHub Enterprise）

set -e  # 遇到错误立即退出
set -o pipefail  # 管道命令中任一失败都算失败

# =============================================================================
# 配置区域
# =============================================================================

# 保护的分支
PROTECTED_BRANCHES="main dev"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# 快速失败计数器
FAILED_CHECKS=0
TOTAL_CHECKS=0

# =============================================================================
# 工具函数
# =============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[✓]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[⚠]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[✗]${NC} $1" >&2
}

log_section() {
    echo -e "\n${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
    echo -e "${BOLD}${BLUE}  $1${NC}" >&2
    echo -e "${BOLD}${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n" >&2
}

fail_check() {
    FAILED_CHECKS=$((FAILED_CHECKS + 1))
    log_error "$1"
    # 快速失败：立即退出
    echo -e "\n${RED}${BOLD}╔═══════════════════════════════════════════════════════════╗${NC}" >&2
    echo -e "${RED}${BOLD}║  🚫 服务器端检查失败！推送被拒绝！                       ║${NC}" >&2
    echo -e "${RED}${BOLD}╚═══════════════════════════════════════════════════════════╝${NC}\n" >&2
    exit 1
}

pass_check() {
    TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
    log_success "$1"
}

# =============================================================================
# 检查函数
# =============================================================================

# 检查1：分支保护
check_branch_protection() {
    log_section "检查1/7：分支保护"

    local branch=$1

    for protected in $PROTECTED_BRANCHES; do
        if [ "$branch" = "$protected" ]; then
            log_error "直接推送到受保护分支 '$branch' 被服务器策略拒绝！"
            log_warning "受保护分支: $PROTECTED_BRANCHES"
            log_info "请使用 Pull Request 工作流"
            echo "" >&2
            log_info "如果你是仓库管理员并需要覆盖此保护：" >&2
            log_info "  1. 临时禁用钩子: mv pre-receive pre-receive.disabled" >&2
            log_info "  2. 推送变更" >&2
            log_info "  3. 重新启用钩子: mv pre-receive.disabled pre-receive" >&2
            fail_check "分支保护检查失败"
        fi
    done

    pass_check "分支保护检查通过"
}

# 检查2：提交消息格式
check_commit_message() {
    log_section "检查2/7：提交消息格式"

    local commit_msg="$1"
    local commit_sha="$2"

    # 检查提交消息长度
    local msg_length=${#commit_msg}
    if [ $msg_length -lt 10 ]; then
        log_error "提交消息太短 (${msg_length}字符，最少10字符)"
        log_error "Commit: $commit_sha"
        log_error "Message: $commit_msg"
        fail_check "提交消息格式检查失败"
    fi

    # 检查提交消息格式 (可选：遵循 Conventional Commits)
    if [[ ! "$commit_msg" =~ ^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: ]]; then
        log_warning "提交消息不符合 Conventional Commits 格式"
        log_warning "推荐格式: type(scope): subject"
        log_warning "例如: feat(auth): add login functionality"
    fi

    pass_check "提交消息格式检查通过"
}

# 检查3：禁止的文件模式
check_forbidden_files() {
    log_section "检查3/7：禁止的文件和模式"

    local oldrev=$1
    local newrev=$2

    # 检查是否有敏感文件
    local forbidden_patterns=(
        '\.env$'
        '\.env\.local$'
        '\.env\.production$'
        '\.(key|pem|p12|pfx|jks)$'
        'id_rsa'
        'id_dsa'
        'password'
        'secret'
    )

    local files_changed
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        # 新分支：检查所有文件
        files_changed=$(git diff-tree -r --name-only --no-commit-id $newrev 2>/dev/null || true)
    else
        # 现有分支：检查变更的文件
        files_changed=$(git diff --name-only $oldrev..$newrev 2>/dev/null || true)
    fi

    for pattern in "${forbidden_patterns[@]}"; do
        local matched_files=$(echo "$files_changed" | grep -E "$pattern" || true)
        if [ -n "$matched_files" ]; then
            log_error "检测到禁止的文件模式: $pattern"
            log_error "匹配的文件:"
            echo "$matched_files" | while read file; do
                log_error "  - $file"
            done
            fail_check "禁止的文件检查失败"
        fi
    done

    pass_check "禁止的文件检查通过"
}

# 检查4：大文件检查
check_large_files() {
    log_section "检查4/7：大文件检查"

    local oldrev=$1
    local newrev=$2
    local max_size=$((10 * 1024 * 1024))  # 10MB

    # 获取新增或修改的文件
    local files_to_check
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        files_to_check=$(git diff-tree -r --name-only --no-commit-id $newrev 2>/dev/null || true)
    else
        files_to_check=$(git diff --name-only $oldrev..$newrev 2>/dev/null || true)
    fi

    local large_files_found=false
    while read -r file; do
        [ -z "$file" ] && continue

        # 获取文件大小
        local file_size=$(git cat-file -s "$newrev:$file" 2>/dev/null || echo 0)

        if [ "$file_size" -gt "$max_size" ]; then
            large_files_found=true
            local size_mb=$((file_size / 1024 / 1024))
            log_error "大文件: $file (${size_mb}MB)"
        fi
    done <<< "$files_to_check"

    if [ "$large_files_found" = true ]; then
        log_error "检测到大于10MB的文件"
        log_info "请使用 Git LFS 管理大文件"
        fail_check "大文件检查失败"
    fi

    pass_check "大文件检查通过"
}

# 检查5：代码质量标记
check_code_quality_markers() {
    log_section "检查5/7：代码质量标记"

    local oldrev=$1
    local newrev=$2

    # 检查是否有TODO/FIXME/HACK等标记（可选）
    local quality_markers=(
        'console\.log'
        'debugger'
        'TODO:'
        'FIXME:'
        'HACK:'
    )

    # 获取新增的代码行
    local new_code
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        new_code=$(git show $newrev 2>/dev/null || true)
    else
        new_code=$(git diff $oldrev..$newrev 2>/dev/null || true)
    fi

    # 检查合并冲突标记（严格）- 使用变量拼接避免误报
    local conflict_start="<""<""<""<""<""<""< HEAD"
    local conflict_sep="=""=""=""=""=""=""="
    local conflict_end=">"">"">"">"">"">"">"">"
    if echo "$new_code" | grep -qE "($conflict_start|$conflict_sep|$conflict_end)"; then
        log_error "检测到未解决的合并冲突标记"
        fail_check "代码质量标记检查失败"
    fi

    # 检查其他标记（警告）
    for marker in 'console\.log' 'debugger'; do
        if echo "$new_code" | grep -q "$marker"; then
            log_warning "检测到调试代码: $marker"
        fi
    done

    pass_check "代码质量标记检查通过"
}

# 检查6：Docker容器依赖管理规范（基于30轮修复教训）
check_docker_dependency_rules() {
    log_section "检查6/7：Docker容器依赖管理规范"

    local oldrev=$1
    local newrev=$2

    # 检查是否修改了依赖相关文件
    local dependency_files
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        dependency_files=$(git diff-tree -r --name-only --no-commit-id $newrev 2>/dev/null | grep -E '(package\.json|package-lock\.json|requirements\.txt|Pipfile|Pipfile\.lock)' || true)
    else
        dependency_files=$(git diff --name-only $oldrev..$newrev 2>/dev/null | grep -E '(package\.json|package-lock\.json|requirements\.txt|Pipfile|Pipfile\.lock)' || true)
    fi

    if [ -n "$dependency_files" ]; then
        log_info "检测到依赖文件变更:"
        echo "$dependency_files" | while read file; do
            log_info "  - $file"
        done

        # 检查是否有 npm workspaces 结构破坏
        if echo "$dependency_files" | grep -q 'frontend/e2e/package-lock\.json'; then
            log_error "检测到子目录的 package-lock.json 变更"
            log_error "这可能破坏 npm workspaces 依赖结构"
            log_info "正确做法："
            log_info "  1. 只在根目录运行 'npm ci'"
            log_info "  2. 子目录只运行 'npm run build/test'"
            fail_check "Docker依赖管理规范检查失败"
        fi

        log_info "依赖变更已记录，请确保在Docker容器中测试"
    fi

    pass_check "Docker依赖管理规范检查通过"
}

# 检查7：根目录守卫
check_root_directory_guard() {
    log_section "检查7/12：根目录守卫"

    local oldrev=$1
    local newrev=$2

    # 获取根目录新增或修改的文件
    local root_files
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        root_files=$(git diff-tree -r --name-only --no-commit-id $newrev 2>/dev/null | grep -E '^[^/]+\.' || true)
    else
        root_files=$(git diff --name-only --diff-filter=AM $oldrev..$newrev 2>/dev/null | grep -E '^[^/]+\.' || true)
    fi

    if [ -z "$root_files" ]; then
        pass_check "根目录守卫检查通过"
        return 0
    fi

    # 允许的根目录文件模式
    local allowed_patterns=(
        '^\.'  # 隐藏文件/配置文件
        '^package\.json$'
        '^package-lock\.json$'
        '^docker-compose.*\.yml$'
        '^Dockerfile.*'
        '^Makefile$'
        '^(setup|install|configure|build|deploy|test|safe-push|passport)\.(sh|py|js)$'
        '^(README|CODE_OF_CONDUCT|CONTRIBUTING|SECURITY|CHANGELOG|LICENSE|AUTHORS|NOTICE)\.md$'
        '^(requirements|Pipfile|Gemfile|go\.mod|Cargo\.toml).*'
    )

    # 检查每个根目录文件
    local forbidden_files=""
    while read -r file; do
        [ -z "$file" ] && continue

        local is_allowed=false
        for pattern in "${allowed_patterns[@]}"; do
            if echo "$file" | grep -qE "$pattern"; then
                is_allowed=true
                break
            fi
        done

        if [ "$is_allowed" = false ]; then
            forbidden_files="${forbidden_files}  - $file\n"
        fi
    done <<< "$root_files"

    if [ -n "$forbidden_files" ]; then
        log_error "检测到根目录不允许的文件："
        echo -e "$forbidden_files" >&2
        log_info "允许的文件类型："
        log_info "  - 配置文件（.开头）"
        log_info "  - 标准文档（README, LICENSE等）"
        log_info "  - 安装脚本（setup.sh, install.sh等）"
        log_info "  - Docker文件（docker-compose.yml, Dockerfile）"
        fail_check "根目录守卫检查失败"
    fi

    pass_check "根目录守卫检查通过"
}

# 检查8：YAML/JSON 文件语法
check_file_syntax() {
    log_section "检查8/12：YAML/JSON 文件语法"

    local oldrev=$1
    local newrev=$2

    # 获取修改的 YAML/JSON 文件
    local config_files
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        config_files=$(git diff-tree -r --name-only --no-commit-id $newrev 2>/dev/null | grep -E '\.(yml|yaml|json)$' || true)
    else
        config_files=$(git diff --name-only $oldrev..$newrev 2>/dev/null | grep -E '\.(yml|yaml|json)$' || true)
    fi

    if [ -z "$config_files" ]; then
        pass_check "文件语法检查跳过（无配置文件变更）"
        return 0
    fi

    local syntax_errors=false
    while read -r file; do
        [ -z "$file" ] && continue

        # 获取文件内容
        local file_content=$(git show "$newrev:$file" 2>/dev/null || true)

        # YAML 基本语法检查
        if echo "$file" | grep -qE '\.(yml|yaml)$'; then
            # 检查基本 YAML 语法错误
            if echo "$file_content" | grep -qE '^\s*\t'; then
                log_error "YAML 文件包含制表符（应使用空格）: $file"
                syntax_errors=true
            fi
            if echo "$file_content" | grep -qE '^[^#]*:[^/].*[^:]$' | grep -qE ':\s*[^"\x27\s].*:\s*[^"\x27\s]'; then
                log_warning "可能的 YAML 语法问题: $file"
            fi
        fi

        # JSON 基本语法检查
        if echo "$file" | grep -qE '\.json$'; then
            # 检查基本 JSON 结构
            if ! echo "$file_content" | grep -qE '^\s*[\{\[].*[\}\]]\s*$'; then
                log_warning "可能的 JSON 语法问题: $file"
            fi
        fi
    done <<< "$config_files"

    if [ "$syntax_errors" = true ]; then
        fail_check "文件语法检查失败"
    fi

    pass_check "文件语法检查通过"
}

# 检查9：文件名冲突检测
check_filename_conflicts() {
    log_section "检查9/12：文件名冲突检测"

    local oldrev=$1
    local newrev=$2

    # 获取所有文件
    local all_files=$(git ls-tree -r --name-only $newrev 2>/dev/null || true)

    # 转换为小写并查找重复
    local conflicts=$(echo "$all_files" | tr '[:upper:]' '[:lower:]' | sort | uniq -d)

    if [ -n "$conflicts" ]; then
        log_error "检测到文件名大小写冲突（跨平台问题）："
        while read -r conflict; do
            [ -z "$conflict" ] && continue
            # 找到实际的冲突文件
            local actual_files=$(echo "$all_files" | grep -i "^${conflict}$")
            log_error "冲突: $actual_files"
        done <<< "$conflicts"
        log_info "Windows 不区分大小写，Linux/Mac 区分"
        log_info "请重命名文件以避免冲突"
        fail_check "文件名冲突检查失败"
    fi

    pass_check "文件名冲突检查通过"
}

# 检查10：NPM Workspaces 架构保护（增强版）
check_npm_workspaces_enhanced() {
    log_section "检查10/12：NPM Workspaces 架构保护（增强）"

    local oldrev=$1
    local newrev=$2

    # 获取变更的文件
    local changed_files
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        changed_files=$(git diff-tree -r --name-only --no-commit-id $newrev 2>/dev/null || true)
    else
        changed_files=$(git diff --name-only $oldrev..$newrev 2>/dev/null || true)
    fi

    local violations=""

    # 1. 检查子目录的 package-lock.json
    if echo "$changed_files" | grep -qE '^(frontend|backend)/[^/]+/package-lock\.json$'; then
        violations="${violations}❌ 检测到子目录的 package-lock.json 变更\n"
        violations="${violations}   这会破坏 npm workspaces 依赖结构\n"
    fi

    # 2. 检查工作流文件中的危险命令
    local workflow_files=$(echo "$changed_files" | grep -E '\.github/workflows/.*\.yml$' || true)
    if [ -n "$workflow_files" ]; then
        while read -r workflow; do
            [ -z "$workflow" ] && continue
            local content=$(git show "$newrev:$workflow" 2>/dev/null || true)

            # 检查子目录的 npm ci/install
            if echo "$content" | grep -qE 'cd\s+(frontend|backend)/[^/]+.*npm\s+(ci|install)'; then
                violations="${violations}❌ 工作流文件包含子目录 npm ci/install: $workflow\n"
            fi
        done <<< "$workflow_files"
    fi

    # 3. 检查脚本文件中的危险命令
    local script_files=$(echo "$changed_files" | grep -E '\.(sh|py|js|Makefile)$' || true)
    if [ -n "$script_files" ]; then
        while read -r script; do
            [ -z "$script" ] && continue
            local content=$(git show "$newrev:$script" 2>/dev/null || true)

            # 检查子目录的 npm ci/install
            if echo "$content" | grep -qE '(frontend|backend)/[^/]+.*npm\s+(ci|install)'; then
                violations="${violations}⚠️  脚本文件可能包含子目录 npm 操作: $script\n"
            fi
        done <<< "$script_files"
    fi

    if [ -n "$violations" ]; then
        log_error "NPM Workspaces 架构违规："
        echo -e "$violations" >&2
        log_info "正确做法："
        log_info "  1. 只在根目录运行 'npm ci'"
        log_info "  2. 子目录只运行 'npm run build/test'"
        log_info "  3. 工具使用 'npx' 而非全局安装"
        fail_check "NPM Workspaces 架构保护失败"
    fi

    pass_check "NPM Workspaces 架构保护通过"
}

# 检查11：Scripts-Golden 核心脚本保护
check_scripts_golden_protection() {
    log_section "检查11/12：Scripts-Golden 核心脚本保护"

    local oldrev=$1
    local newrev=$2

    # 检查 scripts-golden 目录的修改
    local golden_changes
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        golden_changes=$(git diff-tree -r --name-only --no-commit-id $newrev 2>/dev/null | grep '^scripts-golden/' || true)
    else
        golden_changes=$(git diff --name-only $oldrev..$newrev 2>/dev/null | grep '^scripts-golden/' || true)
    fi

    if [ -n "$golden_changes" ]; then
        log_error "检测到 scripts-golden 目录的修改："
        echo "$golden_changes" | while read file; do
            log_error "  - $file"
        done
        log_warning "scripts-golden 目录包含核心安全脚本"
        log_info "修改这些脚本需要："
        log_info "  1. 安全审查"
        log_info "  2. 团队批准"
        log_info "  3. 详细的变更说明"
        log_info "如果确实需要修改，请联系项目维护人员"
        fail_check "Scripts-Golden 保护检查失败"
    fi

    pass_check "Scripts-Golden 保护检查通过"
}

# 检查12：本地测试通行证（如果可用）
check_local_test_passport() {
    log_section "检查12/12：本地测试通行证验证"

    # 注意：服务器端可能无法验证本地通行证
    # 这里只做警告，不做强制检查
    log_warning "服务器端无法验证本地测试通行证"
    log_warning "请确保推送前已运行本地测试"
    log_info "推荐工作流："
    log_info "  1. ./test (运行本地测试)"
    log_info "  2. ./passport (检查通行证)"
    log_info "  3. ./safe-push (安全推送)"

    pass_check "本地测试通行证检查跳过（警告）"
}

# =============================================================================
# 主逻辑
# =============================================================================

log_section "🛡️ 服务器端 Pre-Receive Hook 启动"
log_info "快速失败模式：任何检查失败都将立即终止推送"
log_info "防止绕过本地钩子的最后一道防线"

# 读取推送的引用
while read oldrev newrev refname
do
    # 提取分支名
    branch=$(echo "$refname" | sed 's/refs\/heads\///')

    log_section "推送信息"
    log_info "分支: $branch"
    log_info "旧版本: ${oldrev:0:8}"
    log_info "新版本: ${newrev:0:8}"

    # 如果是删除分支，跳过检查
    if [ "$newrev" = "0000000000000000000000000000000000000000" ]; then
        log_warning "删除分支操作，跳过检查"
        continue
    fi

    # 执行所有检查（快速失败）
    check_branch_protection "$branch"
    check_forbidden_files "$oldrev" "$newrev"
    check_large_files "$oldrev" "$newrev"
    check_code_quality_markers "$oldrev" "$newrev"
    check_docker_dependency_rules "$oldrev" "$newrev"
    check_root_directory_guard "$oldrev" "$newrev"
    check_file_syntax "$oldrev" "$newrev"
    check_filename_conflicts "$oldrev" "$newrev"
    check_npm_workspaces_enhanced "$oldrev" "$newrev"
    check_scripts_golden_protection "$oldrev" "$newrev"
    check_local_test_passport

    # 检查每个提交的消息
    log_section "提交消息检查"
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        # 新分支：检查所有提交
        commits=$(git rev-list $newrev 2>/dev/null || true)
    else
        # 现有分支：只检查新提交
        commits=$(git rev-list $oldrev..$newrev 2>/dev/null || true)
    fi

    commit_count=0
    while read -r commit; do
        [ -z "$commit" ] && continue
        commit_count=$((commit_count + 1))

        commit_msg=$(git log --format=%B -n 1 $commit 2>/dev/null || echo "")
        check_commit_message "$commit_msg" "${commit:0:8}"
    done <<< "$commits"

    log_info "检查了 $commit_count 个提交"

done

# 所有检查通过
echo -e "\n${GREEN}${BOLD}╔═══════════════════════════════════════════════════════════╗${NC}" >&2
echo -e "${GREEN}${BOLD}║  ✅ 所有服务器端检查通过！允许推送！                    ║${NC}" >&2
echo -e "${GREEN}${BOLD}╚═══════════════════════════════════════════════════════════╝${NC}\n" >&2
log_success "通过检查: $TOTAL_CHECKS 项"
log_success "失败检查: $FAILED_CHECKS 项"

exit 0
