# Bravo 项目开发规范

## 1. 核心理念与原则

### 1.1. 开发哲学

- **渐进式改进**：小步快跑，频繁提交可编译、可通过测试的代码。
- **从现有代码中学习**：在动手编码前，先研究项目中的既有模式和约定。
- **实用主义至上**：规则服务于项目，根据实际情况灵活应变，不死守教条。
- **代码清晰为王**：优先选择简单、直白、易于理解的实现，而非追求所谓的“聪明”技巧。
- **单一职责**：每个函数或类只做一件事。
- **避免过早抽象**：只在必要时进行抽象，避免过度设计。

### 1.2. 核心工作原则

- **容器化开发**：所有开发、构建、测试等工作都必须在 Docker 容器中进行，并优先使用国内镜像源。
- **本地测试优先**：任何代码变更都必须在本地完整测试通过后，才能提交。CI/CD 只作为验证手段，而非测试工具。
- **深入分析问题**：遇到错误时，必须深入分析，找到根本原因，而不是只做表面修复。
- **系统性思维**：建立检查清单（Checklist），一次性找出所有相关问题，系统性地解决。
- **专业程序员思维**：严格遵循“思考 -> 搜索 -> 复现 -> 修复 -> 验证”的流程，禁止凭感觉猜测。
- **做好工作准备**：开始任务前，必须充分理解上下文，回顾之前的思路和计划，避免重复劳动。
- **拒绝走捷径**：杜绝简化问题、投机取巧或任何形式的“偷懒”行为。
- **发挥主观能动性**：作为资深开发者，应主动探索和使用工具（尤其是 Web 浏览器）来解决问题，而不是被动等待指令。
- **表明身份**：每次对话，请标注是由哪个模型回答的，并给出真实模型名称。

## 2. 开发工作流

### 2.1. 阶段一：规划与分解 (IMPLEMENTATION_PLAN.md)

对于复杂任务，必须先进行分解，并在根目录创建 `IMPLEMENTATION_PLAN.md` 文件：

```markdown
## 阶段 N：[阶段名称]

**目标**：[描述该阶段要交付的具体产出物]
**成功标准**：[定义清晰、可测试的完成标准]
**测试**：[列出需要编写的具体测试用例]
**状态**：[未开始 | 进行中 | 完成]
```

- 任务期间，持续更新此文件的状态。
- 所有阶段完成后，删除此文件。

### 2.2. 阶段二：编码实现

严格遵循测试驱动开发（TDD）的节奏：

1.  **理解**：研究代码库中的现有模式。
2.  **写测试 (Red)**：为新功能编写一个失败的测试。
3.  **写代码 (Green)**：编写最精简的代码，让测试通过。
4.  **重构 (Refactor)**：在测试保护下，优化和清理代码。
5.  **提交**：提交代码时，附带清晰的提交信息，并关联到开发计划。

### 2.3. 阶段三：问题排查与分析

1.  **收集信息**：完整复制错误日志和堆栈信息。
2.  **分析根因**：深入分析，找到问题的本质。
3.  **建立检查清单**：系统性地列出所有可能的故障点进行排查。
4.  **一次性修复**：在定位所有问题后，进行统一修复。
5.  **本地验证**：修复后，必须在本地环境中验证修复的有效性。

### 2.4. 遇到困难时（“三振出局”原则）

当一个问题尝试 **3次** 仍未解决时，**必须停止** 并遵循以下步骤：

1.  **记录失败**：详细记录尝试过的方法、完整的错误信息以及你对失败原因的分析。
2.  **研究替代方案**：在代码库或网络上寻找 2-3 个相似的实现，分析其不同之处。
3.  **质疑基础**：反思当前的方向是否正确。这是否是合适的抽象层级？问题能否进一步分解？有没有更简单的方法？
4.  **切换视角**：尝试使用不同的库、框架特性或架构模式，甚至可以考虑移除而非增加抽象。

## 3. 技术标准与规范

### 3.1. 架构原则

- **组合优于继承**：优先使用依赖注入和组合。
- **接口优于实现**：面向接口编程，提高代码的可测试性和灵活性。
- **显式优于隐式**：确保数据流和依赖关系清晰明确。

### 3.2. 代码质量

- **提交前检查**：
  - 运行格式化工具和代码检查器。
  - 自我审查（Self-Review）所有代码变更。
  - 确保提交信息清晰地解释了“为什么”要这么改。
- **数据库**：数据库相关的修改必须在本地连接真实数据库进行测试。
- **配置**：配置文件的修改必须在本地验证其是否生效。

### 3.3. 错误处理

- **快速失败**：出现错误时应立即中断，并提供描述性的错误信息。
- **包含上下文**：错误信息应包含足够的调试上下文。
- **分层处理**：在合适的应用层级处理错误。
- **禁止静默吞噬异常**：绝不允许忽略或隐藏任何异常。

### 3.4. 测试规范

- **测试驱动**：尽可能采用测试驱动开发。
- **本地测试要求**：
  - **后端**：所有变更必须通过本地 `pytest` 验证。
  - **前端**：所有变更必须通过本地 `npm test` 验证。
- **测试内容**：测试代码的行为，而不是其内部实现。
- **测试独立**：每个测试都应是确定性的，不依赖于其他测试。
- **测试命名**：测试名称应清晰地描述其测试的场景。

### 3.5. 提交信息规范

- 必须包含问题分析过程。
- 必须说明采用的修复方案。
- 必须说明预期的结果。
- 必须包含所有涉及文件的列表。

## 4. 质量保障

### 4.1. "完成"的定义 (Definition of Done)

一项任务只有在满足以下所有条件时，才能被视为“完成”：

- [ ] 所有新代码都有对应的测试，且所有测试都已通过。
- [ ] 代码遵循项目既有的编码规范和约定。
- [ ] 代码检查器（Linter）和格式化工具没有任何警告。
- [ ] 提交信息清晰、规范。
- [ ] 实现方案与 `IMPLEMENTATION_PLAN.md` 中的计划一致。
- [ ] 代码中没有遗留不带关联 Issue ID 的 `TODO` 注释。

### 4.2. 决策框架

当面临多个可行的技术方案时，按照以下优先级进行决策：

1.  **可测试性**：哪个方案更容易被测试？
2.  **可读性**：6 个月后，其他人能轻松理解这个方案吗？
3.  **一致性**：哪个方案更符合项目现有的风格和模式？
4.  **简洁性**：哪个方案是当下最简单的有效解决方案？
5.  **可逆性**：如果未来需要修改，哪个方案的成本更低？

## 5. 关键纪律

### 5.1. 永远不要 (Don't)

- 使用 `--no-verify` 等方式绕过 Git 提交钩子。
- 禁用或注释掉测试，而不是修复它们。
- 提交任何无法编译或未通过测试的代码。
- 基于假设进行编码，必须通过阅读现有代码或文档来验证。

### 5.2. 始终坚持 (Do)

- 渐进式地提交可工作的代码。
- 随时更新 `IMPLEMENTATION_PLAN.md`。
- 从现有代码和实现中学习。
- 在 3 次尝试失败后，立即停止并重新评估。
