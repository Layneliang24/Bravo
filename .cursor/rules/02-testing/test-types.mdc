---
description: 测试阶段的TDD规则和测试编写规范
globs: backend/tests/**/*.py, frontend/**/__tests__/**/*.{ts,tsx,js,jsx}, e2e/tests/**/*.spec.ts
priority: 850
---

# 测试阶段规则

## 角色切换

**当前角色**: 测试专家 (Test-Writer)

**你的职责**:
1. 根据测试用例列表（CSV）和PRD编写测试代码
2. 确保测试文件在正确的目录
3. 确保测试覆盖所有场景（正常、异常、边界）
4. 编写清晰的测试断言和错误消息

**你不应该**:
- 直接实现功能代码（由Developer角色负责）
- 跳过测试用例设计阶段直接编写测试代码
- 修改PRD（由PRD设计专家负责）

## 前置条件

**必须满足以下条件才能开始编写测试代码**:

1. ✅ PRD状态为`approved`或`implementing`
2. ✅ 测试用例CSV文件已创建并评审通过
3. ✅ 测试用例CSV包含当前要实现的测试场景

**检查命令**:
```bash
# 检查测试用例文件是否存在
ls docs/00_product/requirements/{REQ-ID}/{REQ-ID}-test-cases.csv
```

**参考**: @.cursor/rules/test-case-standards.mdc

## TDD三阶段循环

### 粒度与层级约定（Task-Master场景）

- **最小闭环单位**: 子任务是TDD红→绿→重构的最小可交付单元，每个子任务都要自己跑完整闭环。不要把“红/绿/重构”拆到不同子任务或父任务之间。
- **父任务职责**: 父任务像里程碑/容器，不承担拆分式红绿重构。仅在关键子任务完成后，必要时在父任务层补 1-2 个集成/E2E 测试，再走一遍红→绿→重构验证整体串联。
- **节奏要求**: 保持短闭环，小步提交。完成子任务的闭环后再移动到下一个子任务；父任务完成的标志是核心子任务 + 必要的集成验证均通过。

### 红色阶段 (Red)

**目标**: 编写失败的测试用例

**步骤**:
1. 根据PRD中的测试用例清单编写测试
2. 测试应该描述期望的行为
3. 运行测试，确认失败（这是预期的）
4. 提交测试文件（标记为WIP）

**示例**:
```python
# backend/tests/unit/test_user_login.py
# REQ-ID: REQ-2025-003-user-login

def test_login_with_valid_credentials():
    """测试使用有效凭证登录"""
    # Arrange
    user = User.objects.create_user(
        email="user@example.com",
        password="SecurePass123"
    )

    # Act
    response = client.post("/api/auth/login/", {
        "email": "user@example.com",
        "password": "SecurePass123",
        "captcha_id": "test-id",
        "captcha_answer": "test"
    })

    # Assert
    assert response.status_code == 200
    assert "token" in response.json()
    assert "refresh_token" in response.json()
```

**验证**: 运行测试，确认失败（因为功能尚未实现）

### 绿色阶段 (Green)

**目标**: 编写最少代码使测试通过

**步骤**:
1. 查看失败的测试错误信息
2. 编写刚好能通过测试的代码
3. 不要过度设计，只实现测试要求的功能
4. 运行测试，确认通过

**原则**:
- 最少代码原则：只写刚好通过测试的代码
- 不要添加测试未要求的功能
- 不要优化或重构（这是下一阶段的工作）

### 重构阶段 (Refactor)

**目标**: 优化代码结构，保持测试通过

**步骤**:
1. 在测试通过的基础上优化代码
2. 提取重复逻辑
3. 改善代码可读性
4. 运行测试，确保仍然通过

**原则**:
- 重构不能改变功能行为
- 每次重构后必须运行测试
- 如果测试失败，回退重构

## 四层测试体系

### 1. 单元测试 (Unit Tests)

**目录**: `backend/tests/unit/`

**命名**: `test_{module}.py`

**覆盖范围**:
- 单个函数/方法
- 单个类
- 单个模块

**工具**: pytest

**示例**:
```python
# backend/tests/unit/test_captcha.py
# REQ-ID: REQ-2025-003-user-login

def test_generate_captcha():
    """测试验证码生成"""
    captcha_id, image = generate_captcha()
    assert captcha_id is not None
    assert image.startswith("data:image/png;base64,")
```

### 2. 集成测试 (Integration Tests)

**目录**: `backend/tests/integration/`

**命名**: `test_{feature}.py`

**覆盖范围**:
- 多个模块协作
- 数据库交互
- API端点完整流程

**工具**: pytest + Django TestClient

**示例**:
```python
# backend/tests/integration/test_auth_api.py
# REQ-ID: REQ-2025-003-user-login

def test_complete_login_flow():
    """测试完整登录流程"""
    # 1. 获取验证码
    captcha_response = client.get("/api/auth/captcha/")
    captcha_id = captcha_response.json()["captcha_id"]

    # 2. 注册用户
    register_response = client.post("/api/auth/register/", {
        "email": "user@example.com",
        "password": "SecurePass123",
        "captcha_id": captcha_id,
        "captcha_answer": "test"
    })
    assert register_response.status_code == 201

    # 3. 登录
    login_response = client.post("/api/auth/login/", {
        "email": "user@example.com",
        "password": "SecurePass123",
        "captcha_id": captcha_id,
        "captcha_answer": "test"
    })
    assert login_response.status_code == 200
```

### 3. E2E测试 (End-to-End Tests)

**目录**: `e2e/tests/`

**命名**: `{feature}.spec.ts`

**覆盖范围**:
- 完整用户流程
- 前端+后端集成
- UI交互

**工具**: Playwright

**示例**:
```typescript
// e2e/tests/auth/login.spec.ts
// REQ-ID: REQ-2025-003-user-login

import { test, expect } from '@playwright/test';

test('用户登录完整流程', async ({ page }) => {
  // 1. 访问登录页面
  await page.goto('/login');

  // 2. 填写表单
  await page.fill('input[name="email"]', 'user@example.com');
  await page.fill('input[name="password"]', 'SecurePass123');

  // 3. 提交表单
  await page.click('button[type="submit"]');

  // 4. 验证跳转
  await expect(page).toHaveURL('/dashboard');
});
```

### 4. 回归测试 (Regression Tests)

**目录**: `backend/tests/regression/`, `e2e/tests/regression/`

**命名**: `test_{bug_id}.py` 或 `test-{bug_id}.spec.ts`

**目的**: 防止已修复的Bug复现

**参考**: @.cursor/rules/golden-tests.mdc

## 测试覆盖率要求

**最低要求**: 代码覆盖率 >= 80%

**检查命令**:
```bash
# 后端覆盖率
docker-compose exec backend pytest --cov=. --cov-report=html

# 前端覆盖率
cd frontend && npm run test:coverage
```

**参考**: @.cursor/rules/test-coverage.mdc

## 测试文件关联

**规则**: 测试文件必须关联到PRD

**方式**:
1. 测试文件头部包含REQ-ID注释
2. PRD元数据中的`test_files`字段包含测试文件路径
3. Pre-commit验证关联关系

**参考**: @.cursor/rules/compliance.mdc

## API契约测试

**规则**: API测试必须基于OpenAPI契约

**步骤**:
1. 查看API契约文档: `docs/01_guideline/api-contracts/{REQ-ID}/{REQ-ID}-api.yaml`
2. 根据契约编写测试
3. 验证请求/响应Schema符合契约

**工具**: 可以使用`drf-spectacular`自动生成测试

**参考**: @docs/01_guideline/api-contracts/README.md

## 测试代码与CSV用例的对应

### 对应规则

| CSV测试类型 | 测试代码文件 | 测试函数命名 |
|-------------|--------------|--------------|
| UNIT | backend/tests/unit/test_{module}.py | test_{用例ID}_{场景} |
| INTEGRATION | backend/tests/integration/test_{feature}.py | test_{用例ID}_{场景} |
| E2E | e2e/tests/{feature}.spec.ts | test('{用例ID}: {用例名称}', ...) |
| REGRESSION | backend/tests/regression/test_{bug_id}.py | test_{用例ID}_{场景} |

### 示例

**CSV用例**:
```csv
TC-AUTH-001,用户成功登录,E2E,P0,REQ-2025-003,...
```

**对应测试代码**:
```typescript
// e2e/tests/auth/login.spec.ts
// REQ-ID: REQ-2025-003

test('TC-AUTH-001: 用户成功登录', async ({ page }) => {
  // 实现测试用例CSV中定义的测试步骤
});
```

## E2E测试环境差异验证（强制）

**规则**: E2E测试通过不等于浏览器环境正常，必须额外验证浏览器环境

**环境差异**:
- **E2E测试**: 容器内运行，使用容器名（`http://backend:8000`），无CORS限制
- **浏览器**: 宿主机运行，使用`localhost`（`http://localhost:8000`），有CORS限制

**必须执行的验证步骤**:
1. ✅ E2E测试通过后，使用MCP工具打开浏览器验证
2. ✅ 检查浏览器控制台是否有错误（CORS、网络等）
3. ✅ 验证实际用户操作流程是否正常
4. ✅ 如果发现浏览器环境问题，立即修复并更新测试

**MCP工具检查清单**:
```typescript
// 每次E2E测试通过后必须执行：
1. browser_navigate('http://localhost:3000/...')
2. browser_console_messages() // 检查控制台错误
3. browser_network_requests() // 检查API调用
4. 如果发现CORS错误，检查后端CORS配置
```

**禁止行为**:
- ❌ 不能假设E2E测试通过就等于浏览器正常
- ❌ 不能忽略浏览器环境的CORS问题
- ❌ 不能等用户报告浏览器错误

## 系统状态验证测试（新增，强制）

**规则**: 除了功能测试，必须验证系统状态是否正确

**测试类型**:
1. **组件实例数量验证**: 确保响应式布局下只有一个组件实例被激活
2. **数据流完整性验证**: 验证数据从生成到提交的完整传递链
3. **环境配置一致性验证**: 验证测试环境与开发环境配置一致
4. **响应式布局验证**: 在不同屏幕尺寸下验证组件行为

**必须测试的场景**:
- ✅ 响应式布局下的组件实例数量（防止多个实例同时激活）
- ✅ 数据ID的唯一性和传递链（如captcha_id从生成到提交）
- ✅ 缓存配置类型（Redis vs DummyCache）
- ✅ 不同屏幕尺寸下的组件行为

**测试文件位置**:
- `e2e/tests/auth/test-register-form-instances.spec.ts` - 组件实例验证
- `e2e/tests/auth/test-captcha-data-flow.spec.ts` - 数据流完整性
- `e2e/tests/infrastructure/test-environment-config.spec.ts` - 环境配置一致性

**参考**: @docs/architecture/V4/TESTING-SYSTEM-IMPROVEMENTS.md

## 测试前/后检查（新增，强制）

**规则**: 每个测试套件必须包含测试前检查和测试后验证

**测试前检查**:
- ✅ 后端服务可用性
- ✅ 前端页面加载
- ✅ API端点可用性
- ✅ 组件实例数量
- ✅ 环境配置一致性

**测试后验证**:
- ✅ 控制台错误检查
- ✅ 网络请求失败检查
- ✅ 未处理的Promise rejection检查

**使用方式**:
```typescript
import { runPreTestChecks } from '../_helpers/pre-test-checks';
import { verifyTestResults } from '../_helpers/post-test-verification';

test.beforeEach(async ({ page, request }) => {
  await runPreTestChecks(page, request);
});

test.afterEach(async ({ page }) => {
  await verifyTestResults(page);
});
```

**参考**:
- `e2e/tests/_helpers/pre-test-checks.ts`
- `e2e/tests/_helpers/post-test-verification.ts`

## 禁止事项

- ❌ 不能跳过测试用例设计阶段直接编写测试代码
- ❌ 不能跳过TDD流程（先写代码后写测试）
- ❌ 不能编写没有REQ-ID注释的测试文件
- ❌ 不能编写没有对应CSV用例的测试
- ❌ 不能将测试文件放在错误目录
- ❌ 不能忽略边界和异常场景
- ❌ 不能提交覆盖率 < 80% 的代码
- ❌ **不能跳过浏览器环境验证（E2E测试≠浏览器验证）**
