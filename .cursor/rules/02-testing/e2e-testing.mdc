---
description: E2E 测试规则
globs: e2e/tests/**/*.spec.ts
priority: 520
---

# E2E 测试规则

## 范围
- 仅匹配 E2E 测试：`e2e/tests/**/*.spec.ts`
- 不覆盖前端单测/集成测试

## 基本要求
- 测试行为，不测实现细节
- 场景覆盖：成功路径、异常路径、边界条件
- 独立可重复：禁止依赖外部不可控状态
- 超时控制：合理的超时与等待

## 最佳实践
- 使用稳定选择器（data-test-id），避免脆弱的 DOM 选择器
- 避免过长链式等待，优先显式等待关键状态
- 截图/视频：仅在失败时保存，减少存储

## 浏览器控制台错误监听（强制要求）

> [!IMPORTANT]
> **所有 E2E 测试必须使用 `ConsoleErrorListener` 来捕获和控制台错误和未处理的 Promise rejection**

### 问题背景
- Playwright 默认不会因控制台错误而失败测试
- 测试只检查 UI 状态，不检查 JavaScript 错误
- 运行时错误（如 `ReferenceError`）可能被 Promise catch 捕获，但测试应该验证是否有未处理的错误

### 强制使用 ConsoleErrorListener

**所有 E2E 测试必须遵循以下模式**：

```typescript
import { ConsoleErrorListener } from "../_helpers/console-error-listener";

test.describe("功能测试", () => {
  let errorListener: ConsoleErrorListener;

  test.beforeEach(async ({ page }) => {
    // ⚠️ 必须在页面加载前设置监听器
    errorListener = new ConsoleErrorListener(page);
    errorListener.startListening();

    // ... 其他初始化代码（如 goto 页面）
  });

  test.afterEach(async () => {
    // ⚠️ 必须在测试结束时验证是否有错误
    errorListener.assertNoErrors();
    await errorListener.assertNoUnhandledRejections();
  });

  test("具体测试用例", async ({ page }) => {
    // ... 测试代码
  });
});
```

### ConsoleErrorListener 功能
- **监听控制台错误**：捕获所有 `console.error` 输出
- **监听页面错误**：捕获 `pageerror` 事件（包括未处理的异常）
- **监听未处理的 Promise rejection**：捕获 `unhandledrejection` 事件
- **智能过滤**：自动过滤第三方脚本噪音、浏览器警告、预期错误（如网络错误）
- **测试失败机制**：在 `assertNoErrors()` 时如果有错误则测试失败

### 错误过滤配置

`ConsoleErrorListener` 支持智能过滤，可在构造函数中配置：

```typescript
const errorListener = new ConsoleErrorListener(page, {
  ignoreNetworkErrors: true,      // 忽略网络错误（默认 true）
  ignoreThirdPartyErrors: true,   // 忽略第三方脚本错误（默认 true）
  customIgnorePatterns: [         // 自定义忽略模式
    /Chrome extension/i,
    /DevTools/i
  ]
});
```

### 验证要求

**禁止行为**：
- ❌ 禁止不使用 `ConsoleErrorListener` 编写 E2E 测试
- ❌ 禁止在页面加载后设置监听器（必须在 `beforeEach` 中，页面 `goto` 之前）
- ❌ 禁止在测试结束时跳过 `assertNoErrors()` 验证
- ❌ 禁止忽略 `assertNoUnhandledRejections()` 验证

**必须检查**：
- ✅ 每个测试套件（`test.describe`）必须设置 `errorListener`
- ✅ 监听器必须在页面加载前启动（`beforeEach` 中，`goto` 之前）
- ✅ 测试结束时必须调用 `assertNoErrors()` 和 `assertNoUnhandledRejections()`

## 验证码测试最佳实践（关键）

**核心原则**：验证码存在的意义是防止机器人，但E2E测试本身就是机器人在操作。这是设计上的互斥。

### 验证码测试的"调试地狱"问题

**为什么验证码E2E测试特别难调试？**

1. **设计悖论**：验证码防机器人，但E2E测试就是机器人
2. **异步竞态**：验证码图片加载、网络延迟、DOM渲染的时序问题
3. **状态黑盒**：前后端Session/Redis数据可能不同步
4. **随机性**：AI无法预测验证码答案，无法推导预期结果

### 正确的测试策略（必须遵循）

**⚠️ 关键原则：不要尝试识别真正的验证码（OCR等），这是自找麻烦**

#### 方案A：万能验证码（推荐，测试环境专用）

**逻辑**：后端在测试环境下，如果输入的验证码是特定值（如`666666`），则直接通过验证。

**优点**：
- 彻底消除随机性和时序问题
- AI可以一眼看懂逻辑
- 测试稳定可靠

**实现示例**：
```typescript
// 测试用例中永远输入万能验证码
await page.fill('#captcha', '666666');
await page.click('#login-btn');
```

#### 方案B：Mock网络请求（前端拦截）

**逻辑**：在Playwright/Cypress层面拦截验证码验证API，直接返回成功响应。

**优点**：
- 不依赖后端修改
- 测试运行速度快

**实现示例**：
```typescript
await page.route('**/api/auth/preview/', async route => {
  await route.fulfill({
    status: 200,
    body: JSON.stringify({ valid: true })
  });
});
```

### 当遇到验证码测试失败时

**必须执行的检查清单**：

1. [ ] **质疑测试策略**：是否应该使用万能验证码或Mock？
2. [ ] **检查后端支持**：测试环境是否支持万能验证码？
3. [ ] **检查Mock逻辑**：如果使用Mock，是否正确拦截了请求？
4. [ ] **检查时序问题**：是否使用了`waitForResponse`而不是固定等待时间？
5. [ ] **检查状态同步**：前后端的captcha_id是否一致？

**禁止行为**：
- ❌ 不要尝试识别验证码图片（OCR）
- ❌ 不要通过API获取验证码答案（违反安全原则）
- ❌ 不要无限增加等待时间（治标不治本）
- ❌ 不要只修代码而不质疑测试策略

## 禁止事项
- ❌ 依赖未隔离的外部服务
- ❌ 使用随机 sleep 代替显式等待
- ❌ 将业务逻辑写进测试
- ❌ **尝试识别真正的验证码（OCR等）**
- ❌ **在验证码测试中只修代码而不质疑测试策略**

---

## 规则应用声明

**当AI被路由到此规则时，必须在响应开头明确声明**：

```
[应用规则：@.cursor/rules/02-testing/e2e-testing.mdc]
[切换到测试专家角色]
```

**验证要求**：
- ✅ 必须明确声明应用了此规则
- ✅ 必须遵循本规则中的所有约束和流程
- ✅ 必须切换到测试专家角色
- ✅ 不能跳过声明步骤直接执行操作
